<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Realtime Sync Chat</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    display: flex;
    flex-direction: column;
    height: 100vh;
    font-family: monospace;
    overflow: hidden;
  }

  .half {
    flex: 1;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #top {
    background: black;
    color: white;
  }

  #bottom {
    background: white;
    color: black;
  }

  textarea {
    width: 100%;
    height: 100%;
    border: none;
    background: transparent;
    resize: none;
    outline: none;
    text-align: center;
    font-size: 22px;
    line-height: 1.4;
    overflow-y: auto;
    padding: 0;
  }

  .status-dot {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: red;
    z-index: 10;
  }

  .erase-btn {
    position: absolute;
    bottom: 15px;
    right: 15px;
    background: white;
    border: 2px solid black;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
  }

  .cursor-marker {
    position: absolute;
    width: 2px;
    background: #2196f3;
    animation: blink 1s infinite;
  }

  .selection-overlay {
    position: absolute;
    background: rgba(33,150,243,0.3);
    pointer-events: none;
  }

  @keyframes blink {
    0%, 50%, 100% { opacity: 1; }
    25%, 75% { opacity: 0; }
  }
</style>
</head>
<body>
  <div id="top" class="half">
    <div class="status-dot" id="statusDot"></div>
    <textarea id="remoteText" readonly></textarea>
  </div>

  <div id="bottom" class="half">
    <textarea id="localText" placeholder="Type here..."></textarea>
    <div class="erase-btn" id="eraseBtn">üóëÔ∏è</div>
  </div>

<script>
  const ws = new WebSocket("wss://realtime-bridge.onrender.com");
  const statusDot = document.getElementById("statusDot");
  const localText = document.getElementById("localText");
  const remoteText = document.getElementById("remoteText");
  const eraseBtn = document.getElementById("eraseBtn");

  let clientId = Math.random().toString(36).substr(2, 5);
  let partnerCursor, partnerSelection;
  let partnerScroll = false;

  // Utility
  function setStatus(color){ statusDot.style.background = color; }
  function sendMessage(type, data={}){
    if(ws.readyState===WebSocket.OPEN){
      ws.send(JSON.stringify({ type, id: clientId, ...data }));
    }
  }

  // WebSocket events
  ws.onopen = () => setStatus("red");
  ws.onmessage = e => handleMessage(JSON.parse(e.data));
  ws.onclose = () => setStatus("red");

  function handleMessage(d){
    if(d.id===clientId) return;

    switch(d.type){
      case "status":
        if(d.clients===1) setStatus("red");
        else if(d.clients===2) setStatus("green");
        else if(d.clients>=3) setStatus("yellow");
        break;

      case "text":
        remoteText.value = d.text;
        keepLastLineVisible(remoteText);
        break;

      case "cursor":
        showRemoteCursor(d.cursorPos, d.selectionStart, d.selectionEnd);
        break;

      case "scroll":
        partnerScroll = true;
        remoteText.scrollTop = d.scroll;
        setTimeout(()=>partnerScroll=false, 200);
        break;

      case "erase":
        remoteText.value="";
        break;
    }
  }

  // Input sync
  localText.addEventListener("input", ()=>{
    sendMessage("text",{ text: localText.value });
    keepLastLineVisible(localText);
  });

  // Cursor + selection sync
  ["select","keyup","click","touchend"].forEach(evt=>{
    localText.addEventListener(evt, sendCursorUpdate);
  });

  function sendCursorUpdate(){
    sendMessage("cursor",{
      cursorPos: localText.selectionStart,
      selectionStart: localText.selectionStart,
      selectionEnd: localText.selectionEnd
    });
  }

  // Scroll sync (debounced)
  let lastScroll=0;
  localText.addEventListener("scroll", ()=>{
    if(Math.abs(localText.scrollTop-lastScroll)>2){
      lastScroll=localText.scrollTop;
      sendMessage("scroll",{ scroll: localText.scrollTop });
    }
  });

  // Show partner cursor + selection
  function showRemoteCursor(pos,selStart,selEnd){
    removeMarkers();
    const text=remoteText.value;
    const before=text.substring(0,pos);
    const lines=before.split("\n");
    const lineIndex=lines.length-1;
    const charIndex=lines[lineIndex].length;

    const lineHeight=28;
    const charWidth=12;

    const topOffset=lineIndex*lineHeight+6;
    const leftOffset=(charIndex*charWidth)+(remoteText.clientWidth/2)-(text.length?0:10);

    const cursor=document.createElement("div");
    cursor.className="cursor-marker";
    cursor.style.top=topOffset+"px";
    cursor.style.left=leftOffset+"px";
    cursor.style.height=lineHeight+"px";
    remoteText.parentElement.appendChild(cursor);
    partnerCursor=cursor;

    if(selEnd>selStart){
      const selection=document.createElement("div");
      selection.className="selection-overlay";
      selection.style.top=topOffset+"px";
      selection.style.left=leftOffset+"px";
      selection.style.width=(selEnd-selStart)*charWidth+"px";
      selection.style.height=lineHeight+"px";
      remoteText.parentElement.appendChild(selection);
      partnerSelection=selection;
    }
  }

  function removeMarkers(){
    if(partnerCursor) partnerCursor.remove();
    if(partnerSelection) partnerSelection.remove();
  }

  function keepLastLineVisible(el){
    el.scrollTop=el.scrollHeight;
  }

  // Erase sync
  eraseBtn.onclick=()=>{
    localText.value="";
    sendMessage("text",{ text:"" });
    sendMessage("erase",{});
  };

  // Ping every 1s
  setInterval(()=>sendMessage("ping",{}),1000);
</script>
</body>
</html>
